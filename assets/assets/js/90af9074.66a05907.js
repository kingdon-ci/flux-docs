"use strict";(self.webpackChunkweave_gitops_docs=self.webpackChunkweave_gitops_docs||[]).push([[49759],{32342:(e,t,n)=>{n.d(t,{Z:()=>r});var o=n(67294),i=n(86010);const a="tabItem_Ymn6";function r(e){let{children:t,hidden:n,className:r}=e;return o.createElement("div",{role:"tabpanel",className:(0,i.Z)(a,r),hidden:n},t)}},71125:(e,t,n)=>{n.d(t,{Z:()=>N});var o=n(87462),i=n(67294),a=n(86010),r=n(63735),s=n(16550),l=n(34423),p=n(20636),c=n(99200);function u(e){return function(e){return i.Children.map(e,(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:o,default:i}}=e;return{value:t,label:n,attributes:o,default:i}}))}function m(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??u(n);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function d(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const o=(0,s.k6)(),a=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(a),(0,i.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(o.location.search);t.set(a,e),o.replace({...o.location,search:t.toString()})}),[a,o])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:o}=e,a=m(e),[r,s]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const o=n.find((e=>e.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:t,tabValues:a}))),[l,p]=h({queryString:n,groupId:o}),[u,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[o,a]=(0,c.Nk)(n);return[o,(0,i.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:o}),k=(()=>{const e=l??u;return d({value:e,tabValues:a})?e:null})();(0,i.useLayoutEffect)((()=>{k&&s(k)}),[k]);return{selectedValue:r,selectValue:(0,i.useCallback)((e=>{if(!d({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);s(e),p(e),f(e)}),[p,f,a]),tabValues:a}}var k=n(5730);const g="tabList__CuJ",v="tabItem_LNqP";function y(e){let{className:t,block:n,selectedValue:s,selectValue:l,tabValues:p}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,r.o5)(),m=e=>{const t=e.currentTarget,n=c.indexOf(t),o=p[n].value;o!==s&&(u(t),l(o))},d=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":n},t)},p.map((e=>{let{value:t,label:n,attributes:r}=e;return i.createElement("li",(0,o.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:d,onClick:m},r,{className:(0,a.Z)("tabs__item",v,r?.className,{"tabs__item--active":s===t})}),n??t)})))}function b(e){let{lazy:t,children:n,selectedValue:o}=e;const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===o));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==o}))))}function w(e){const t=f(e);return i.createElement("div",{className:(0,a.Z)("tabs-container",g)},i.createElement(y,(0,o.Z)({},e,t)),i.createElement(b,(0,o.Z)({},e,t)))}function N(e){const t=(0,k.Z)();return i.createElement(w,(0,o.Z)({key:String(t)},e))}},52927:(e,t,n)=>{n.d(t,{Z:()=>r});var o=n(67294),i=n(88746);n(52426);const a={fontSize:16,marginLeft:4,fontVariant:"all-small-caps"};function r(e){let{tiers:t}=e;return o.createElement(i.Z,{title:`This feature is a available on ${t}.`,style:a},t)}},55845:(e,t,n)=>{n.d(t,{ZP:()=>r});var o=n(87462),i=(n(67294),n(3905));const a={toc:[]};function r(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},a,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("strong",{parentName:"p"},"This feature is in alpha and certain aspects will change")),(0,i.kt)("p",{parentName:"admonition"},"We're very excited for people to use this feature.\nHowever, please note that changes in the API, behaviour and security will evolve.\nThe feature is suitable to use in controlled testing environments.")))}r.isMDXComponent=!0},4037:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>p,default:()=>h,frontMatter:()=>l,metadata:()=>c,toc:()=>m});var o=n(87462),i=(n(67294),n(3905)),a=n(52927),r=(n(71125),n(32342),n(77823),n(55845));const s=n.p+"assets/images/manual-promotion-ui-6fd5aea1f366d7d647e2005668b4b106.png",l={title:"Promoting applications",hide_title:!0,toc_max_heading_level:4},p='Promoting applications through pipeline environments <TierLabel tiers="Enterprise" />',c={unversionedId:"pipelines/promoting-applications",id:"version-0.36.0/pipelines/promoting-applications",title:"Promoting applications",description:"Pipelines allow you to configure automatic promotions of applications through a consecutive set of environments, e.g. from dev to staging to production. The environments are defined in the Pipeline resource itself so that each pipeline governs a single application and all the environments to which it is deployed.",source:"@site/versioned_docs/version-0.36.0/pipelines/promoting-applications.mdx",sourceDirName:"pipelines",slug:"/pipelines/promoting-applications",permalink:"/docs/0.36.0/pipelines/promoting-applications",draft:!1,editUrl:"https://github.com/weaveworks/weave-gitops/edit/main/website/versioned_docs/version-0.36.0/pipelines/promoting-applications.mdx",tags:[],version:"0.36.0",frontMatter:{title:"Promoting applications",hide_title:!0,toc_max_heading_level:4},sidebar:"docs",previous:{title:"Authorization",permalink:"/docs/0.36.0/pipelines/authorization"},next:{title:"Using GitOpsTemplates for Pipelines",permalink:"/docs/0.36.0/pipelines/pipelines-templates"}},u={},m=[{value:"Expose the promotion webhook",id:"expose-the-promotion-webhook",level:2},{value:"Setup notifications from leaf clusters",id:"setup-notifications-from-leaf-clusters",level:2},{value:"Pull request",id:"pull-request",level:2},{value:"Security",id:"security",level:3},{value:"Environments and Repositories",id:"environments-and-repositories",level:4},{value:"RBAC",id:"rbac",level:4},{value:"Policy",id:"policy",level:4},{value:"Service Account",id:"service-account",level:4},{value:"Verify Security Context",id:"verify-security-context",level:4},{value:"Tokens",id:"tokens",level:4},{value:"Add markers to app manifests",id:"add-markers-to-app-manifests",level:3},{value:"Supported Git Providers",id:"supported-git-providers",level:3},{value:"Credentials Secret",id:"credentials-secret",level:3},{value:"Define promotion in pipeline resource",id:"define-promotion-in-pipeline-resource",level:3},{value:"Notification",id:"notification",level:2},{value:"Manual promotion",id:"manual-promotion",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Retry Logic",id:"retry-logic",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3}],d={toc:m};function h(e){let{components:t,...l}=e;return(0,i.kt)("wrapper",(0,o.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"promoting-applications-through-pipeline-environments-"},"Promoting applications through pipeline environments ",(0,i.kt)(a.Z,{tiers:"Enterprise",mdxType:"TierLabel"})),(0,i.kt)(r.ZP,{mdxType:"AlphaWarning"}),(0,i.kt)("p",null,"Pipelines allow you to configure automatic promotions of applications through a consecutive set of environments, e.g. from dev to staging to production. The environments are defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pipeline")," resource itself so that each pipeline governs a single application and all the environments to which it is deployed."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"At the moment only applications defined as Flux ",(0,i.kt)("inlineCode",{parentName:"p"},"HelmReleases")," are supported in automatic promotions.")),(0,i.kt)("figure",null,(0,i.kt)("p",null,(0,i.kt)("img",{alt:"an example promotion PR",src:n(63360).Z,width:"1724",height:"1505"})),(0,i.kt)("figcaption",null,"An example of a pull request for an application promotion")),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/docs/0.36.0/pipelines/pipelines-getting-started"},"Getting Started Guide")," describes how to create a basic pipeline for an application so you can visualize its deployments across a series of environments. You may also configure a pipeline in order to promote applications across a series of environments.\nThere are currently two supported strategies for application promotions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pull request strategy: this strategy is used for applications that are delivered via Flux to all environments of a pipeline. Typically, the versions of these applications are stored in Git and therefore pull requests can be used to update them as part of a promotion."),(0,i.kt)("li",{parentName:"ul"},"Notification strategy: this strategy is used when an external CI system is responsible for promoting an application across the environments of a pipeline. In this strategy, the notification controller running on the management cluster is used to forward notifications of succesful promotions to external CI systems.")),(0,i.kt)("p",null,"Before configuring any of the above promotion strategies, you need to setup notifications from all your environments so that whenever a new version gets deployed, the promotion webhook component of the pipeline controller is notified and takes an action based on the pipeline definition. The rest of this guide describes the configuration needed to setup application promotion via pipelines."),(0,i.kt)("h2",{id:"expose-the-promotion-webhook"},"Expose the promotion webhook"),(0,i.kt)("p",null,"Applications deployed in leaf clusters use the Flux notification controller running on each leaf cluster, to notify the management cluster of a successful promotion. This requires network connectivity to be established between the leaf cluster and the management cluster."),(0,i.kt)("p",null,"The component responsible for listening to incoming notifications from leaf clusters is the pipeline controller. It hosts a webhook service that needs to be exposed via an ingress resource to make it available for external calls. Exposing the webhook service is done via the Weave GitOps Enterprise Helm chart values and the configuration used depends on your environment. The example below shows the configuration for NGINX ingress controller and needs to be adjusted if another ingress controller is used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"spec:\n  values:\n    enablePipelines: true\n    pipeline-controller:\n      promotion:\n        ingress:\n          enabled: true\n          className: nginx\n          annotations:\n            cert-manager.io/cluster-issuer: letsencrypt\n          hosts:\n          - host: promotions.example.org\n            paths:\n            - path: /?(.*)\n              pathType: ImplementationSpecific\n          tls:\n          - secretName: promotions-tls\n            hosts:\n            - promotions.example.org\n")),(0,i.kt)("p",null,"You will need the externally reachable URL of this service later on in this guide."),(0,i.kt)("h2",{id:"setup-notifications-from-leaf-clusters"},"Setup notifications from leaf clusters"),(0,i.kt)("p",null,"Once the webhook service is exposed over HTTP/S, you need to create alert/provider resources to send notifications to it from leaf clusters. These notifications represent successful promotions for applications running on the leaf clusters."),(0,i.kt)("p",null,"Successful promotion events are triggered by Flux's ",(0,i.kt)("a",{parentName:"p",href:"https://fluxcd.io/flux/components/notification/"},"notification controller"),". You create a Provider pointing to the promotion webhook exposed earlier and an Alert targeting the app's HelmRelease:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Provider\nmetadata:\n  name: promotion-my-app\nspec:\n  address: "https://promotions.example.org/promotion/pipeline-01/my-app/dev"\n  type: generic-hmac\n  secretRef:\n    name: hmac-secret\n')),(0,i.kt)("p",null,"In the example above, the ",(0,i.kt)("inlineCode",{parentName:"p"},"generic-hmac")," Provider is used to ensure notifications originate from authenticated sources. The referenced Secret, should include a ",(0,i.kt)("inlineCode",{parentName:"p"},"token")," field which holds the HMAC key. The same HMAC key must be specified in the Secret referenced by the ",(0,i.kt)("inlineCode",{parentName:"p"},".spec.promotion.strategy.secretRef.name")," field, so that the pipeline controller can verify any incoming notifications. For more information on the ",(0,i.kt)("inlineCode",{parentName:"p"},"generic-hmac")," Provider, please refer to the notification controller ",(0,i.kt)("a",{parentName:"p",href:"https://fluxcd.io/flux/components/notification/provider/#generic-webhook-with-hmac"},"docs"),"."),(0,i.kt)("p",null,"Note that by default, the promotion webhook endpoint is exposed at ",(0,i.kt)("inlineCode",{parentName:"p"},"/promotion")," as shown in the example above. However you may use rewrite rules in your ingress configuration to omit it, if desired. For example, if using NGINX ingress controller, you may use the following annotation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"annotations:\n  nginx.ingress.kubernetes.io/rewrite-target: /promotion/$1\n")),(0,i.kt)("p",null,"The Provider address can then be set as ",(0,i.kt)("inlineCode",{parentName:"p"},"https://promotions.example.org/pipeline-01/my-app/dev"),"."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"You may also use the ",(0,i.kt)("a",{parentName:"p",href:"https://fluxcd.io/flux/components/notification/provider/#generic-webhook-with-hmac"},"generic webhook provider type that supports HMAC verification")," to ensure incoming notifications originate from authenticated sources.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," field's URL path is comprised of 3 components again:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The namespace of the app's pipeline."),(0,i.kt)("li",{parentName:"ol"},"The name of the pipeline resource."),(0,i.kt)("li",{parentName:"ol"},'The origin environment\'s name. This is the name of the environment that the event is created in, e.g. "dev" for events coming from the "dev" environment.')),(0,i.kt)("p",null,"Weave GitOps Enterprise can then parse the incoming URL path to identify the pipeline resource and look up the next environment for the defined promotion action."),(0,i.kt)("p",null,"An example Alert might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Alert\nspec:\n  eventSeverity: info\n  eventSources:\n  - kind: HelmRelease\n    name: my-app\n  exclusionList:\n  - .*upgrade.*has.*started\n  - .*is.*not.*ready\n  - ^Dependencies.*\n  providerRef:\n    name: promotion-my-app\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Be sure to create the Provider/Alert tuple on ",(0,i.kt)("strong",{parentName:"p"},"each of the leaf clusters\ntargeted by a pipeline"),".")),(0,i.kt)("p",null,"Now as soon as the ",(0,i.kt)("inlineCode",{parentName:"p"},"HelmRelease")," on the first environment defined in the pipeline is bumped (e.g. by Flux discovering a new version in the Helm repository), an event is sent to the promotion webhook which will determine the next action based on the pipeline definition and chosen strategy. The rest of this guide describes how to setup up any of the available strategies depending on your requirements."),(0,i.kt)("h2",{id:"pull-request"},"Pull request"),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"Creating pull requests requires a personal access token with write access to your git repo. If the secret containing the token is compromised (and you could assume\nit as a likely scenario), it could in principle allow someone to delete your production applications."),(0,i.kt)("p",{parentName:"admonition"},"Please make sure you understand the ",(0,i.kt)("a",{parentName:"p",href:"#security"},"Security")," section below before taking the steps to enable automated pull requests.")),(0,i.kt)("p",null,"This section covers adding a promotion by pull request (PR) strategy, so that whenever the application defined in a pipeline\nis upgraded in one of the pipeline's environments, a PR is created that updates the manifest file setting the application version in the next environment."),(0,i.kt)("p",null,"The dynamic nature of GitOps deployments requires you to assist Weave GitOps a little with information on which repository hosts the manifest files,\nhow to authenticate with the repository and the Git provider API, and which file hosts the version definition for each environment."),(0,i.kt)("h3",{id:"security"},"Security"),(0,i.kt)("h4",{id:"environments-and-repositories"},"Environments and Repositories"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Use it in low-risk environments and not in production: pipelines is an alpha feature and not yet production-ready."),(0,i.kt)("li",{parentName:"ol"},"Make sure you have considered possible attack vectors to production, and put controls in place. Some\nof these scenarios are:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In the case of a ",(0,i.kt)("a",{parentName:"li",href:"https://fluxcd.io/flux/guides/repository-structure/#monorepo"},"monorepo"),": you want to ensure that a compromised token for a test cluster cannot end up doing a promotion in production, without at least a pull request review; for example, by using ",(0,i.kt)("a",{parentName:"li",href:"https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners"},"Codeowners"),"."),(0,i.kt)("li",{parentName:"ul"},"In the case of ",(0,i.kt)("a",{parentName:"li",href:"https://fluxcd.io/flux/guides/repository-structure/#repo-per-environment"},"repo per environment")," you want to ensure that a pipeline is configured with your test environment repo URL. You also want to ensure that you have segregation of tokens per environment rather than allowing a token to access any environment repo.")),(0,i.kt)("h4",{id:"rbac"},"RBAC"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Only allow creation of RBAC resources from paths where compliance controls are in place. For example, do not\nallow regular users to create or update RBAC resources; or, if users must create RBAC resources, restrict them by namespace.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},'Follow the principle of "Least Privilege" RBAC as explained in ',(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/security/rbac-good-practices/"},"Kubernetes RBAC Good Practices"),", with emphasis on the following:"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Assign permissions at the namespace level where possible. Use RoleBindings as opposed to ClusterRoleBindings\nto give users rights only within a specific namespace.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Avoid providing wildcard permissions when possible, especially to all resources.\nAs Kubernetes is an extensible system, providing wildcard access gives rights not just to\nall object types that currently exist in the cluster, but also to all object types which are created in the future.")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"Prefer granting access to specific secrets, rather than granting ",(0,i.kt)("inlineCode",{parentName:"li"},"list")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"watch")," on secrets as:")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"It is also important to note that list and watch access also effectively allow users to read Secret contents.")),(0,i.kt)("h4",{id:"policy"},"Policy"),(0,i.kt)("p",null,"By following the guidelines above, you can have a safe initial configuration. However, given there are no deny semantics in ",(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole"},"RBAC"),", you need to guard future changes."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'An RBAC Role or ClusterRole contains rules that represent a set of permissions.\nPermissions are purely additive (there are no "deny" rules).')),(0,i.kt)("p",null,"You should ensure that attempts to break this contract are blocked and detected. You could achieve it\nby using Weave GitOps' ",(0,i.kt)("a",{parentName:"p",href:"../../policy/intro/"},"Policy capabilities"),". The Policy Agent acts in two complementary modes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"../../policy/intro#admission-controller"},"Admission Controller")," protects from any attempt to create non-compliant RBAC resources that would end granting access to the secret."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"../../policy/intro#audit"},"Audit")," helps you identify already existing resources that are out of compliance. For example,\nroles created before policy agent was introduced as admission controller.")),(0,i.kt)("p",null,"Once you have enabled Policy, the ",(0,i.kt)("a",{parentName:"p",href:"../../policy/weave-policy-profile/"},"Policy Library")," gives you a set of\ngood practices policies that will help you keep pipeline secrets secure according to the previous RBAC recommendations. Deploy\nthem as Kustomization based on the following example:"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"In case you don't have access to the Policy Library, work with your Weaveworks Technical Account Manager (TAM) or\nWeaveworks Customer Reliability Engineer (CRE) to help with this step.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: source.toolkit.fluxcd.io/v1\nkind: GitRepository\nmetadata:\n  name: policy-library\n  namespace: flux-system\nspec:\n  interval: 10m0s\n  url: https://github.com/weaveworks/policy-library.git\n  secretRef:\n    name: policy-library-github-credentials\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: rbac-secrets-good-practices\n  namespace: flux-system\nspec:\n  interval: 1m0s\n  sourceRef:\n    kind: GitRepository\n    name: policy-library\n  path: ./goodpractices/kubernetes/rbac/secrets\n  prune: true\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Policies typically allow exclusions, to accommodate privileged workloads like Flux. You can manage them via ",(0,i.kt)("a",{parentName:"p",href:"https://docs.gitops.weave.works/docs/policy/policy-configuration/"},"PolicyConfig"),".\nFor example, in order to allow Flux you could use the following ",(0,i.kt)("inlineCode",{parentName:"p"},"PolicyConfig"),":"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\n  name: allow-flux\nspec:\n  match:\n    apps:\n      - kind: Kustomization\n        name: flux-system\n        namespace: flux-system\n  config:\n    weave.templates.rbac-prohibit-wildcards-policyrule-resources:\n      parameters:\n        exclude_label_key: "app.kubernetes.io/part-of"\n        exclude_label_value: "flux"\n    weave.templates.rbac-prohibit-wildcards-policyrule-verbs:\n      parameters:\n        exclude_label_key: "app.kubernetes.io/part-of"\n        exclude_label_value: "flux"\n    weave.policies.rbac-prohibit-list-secrets:\n      parameters:\n        exclude_label_key: "app.kubernetes.io/part-of"\n        exclude_label_value: "flux"\n    weave.policies.rbac-prohibit-watch-secrets:\n      parameters:\n        exclude_label_key: "app.kubernetes.io/part-of"\n        exclude_label_value: "flux"\n    weave.policies.rbac-prohibit-wildcard-secrets:\n      parameters:\n        exclude_label_key: "app.kubernetes.io/part-of"\n        exclude_label_value: "flux"\n')),(0,i.kt)("p",{parentName:"admonition"},"Remind not allowing users to create RBAC resources without compliance checks. Otherwise, they could create RBAC resources that could escape this runtime control.")),(0,i.kt)("p",null,"In addition to guarding against privilege escalation via RBAC, you should guard against privilege escalation ",(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/security/rbac-good-practices/#workload-creation"},"through workloads"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Permission to create workloads (either Pods, or workload resources that manage Pods) in a namespace implicitly grants access\nto many other resources in that namespace, such as Secrets, ConfigMaps, and PersistentVolumes that can be mounted in Pods")),(0,i.kt)("p",null,"You could do that by creating pipeline namespaces to hold the Pipeline and its Secret, without permission to run workloads. You\ncould enforce the latter one by using the Policy ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/weaveworks/policy-library/blob/main/policies/ControllerProhibitNamespace/policy.yaml"},"Containers Should Not Run In Namespace"),"\nfrom the Policy Library and ",(0,i.kt)("a",{parentName:"p",href:"https://docs.gitops.weave.works/docs/policy/policy-configuration/"},"PolicyConfig")," as follows:"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Update updates when onboarding a new pipeline. Consider using Weave Gitops self-service capabilities\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.gitops.weave.works/docs/gitops-templates/intro/"},"GitOps Templates")," or ",(0,i.kt)("a",{parentName:"p",href:"https://docs.gitops.weave.works/docs/gitopssets/intro/"},"GitOpsSets"),"\nto help you with the task.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\n  name: reject-workloads-pipeline-namespace\nspec:\n  match:\n    namespaces:\n      - podinfo\n  config:\n    weave.policies.containers-should-not-run-in-namespace:\n      parameters:\n        custom_namespace: "podinfo"\n')),(0,i.kt)("h4",{id:"service-account"},"Service Account"),(0,i.kt)("p",null,"To enable the Pipeline Controller to read the secret, we need to grant access via RBAC. The promotion credentials\nsecret needs to be in the same namespace as the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pipeline")," resource on the management cluster. You should create a ",(0,i.kt)("inlineCode",{parentName:"p"},"RoleBinding"),"\nfor the Pipeline Controller ",(0,i.kt)("inlineCode",{parentName:"p"},"ServiceAccount")," in the pipeline namespace. For a pipeline in namespace ",(0,i.kt)("inlineCode",{parentName:"p"},"podinfo"),", it would look like\nthe following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: read-app-promotion-credentials\n  namespace: podinfo # change for the pipeline namespace\nrules:\n  - apiGroups:\n      - ""\n    resourceNames:\n      - "app-promotion-credentials" # change for the secret name holding the pull requests secret\n    resources:\n      - "secrets"\n    verbs:\n      - "get"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pipeline-controller-read-app-promotion-credentials\n  namespace: podinfo\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: read-app-promotion-credentials\nsubjects:\n  - kind: ServiceAccount\n    name: chart-pipeline-controller # change in case pipeline controller service account has a different name in your context\n    namespace: flux-system\n')),(0,i.kt)("h4",{id:"verify-security-context"},"Verify Security Context"),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/weaveworks/weave-gitops-quickstart/tree/main/pipelines-promotions-security"},"pipeline promotions security"),"\nto verify that your environments meets the security context described earlier."),(0,i.kt)("p",null,"Once deployed you could see how the different resources are being rejected. See those rejections in the Violations UI:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"privilege escalation blocked",src:n(63318).Z,width:"1516",height:"849"})),(0,i.kt)("p",null,"In addition, verify that the Pipeline controller can only get the secret by the following tests:"),(0,i.kt)("p",null,"List access is denied:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'$ kubectl get secret -n podinfo  --as=system:serviceaccount:flux-system:chart-pipeline-controller\n\nError from server (Forbidden): secrets is forbidden: User "system:serviceaccount:flux-system:chart-pipeline-controller" cannot list resource "secrets" in API group "" in the namespace "podinfo"\n')),(0,i.kt)("p",null,"Get access is allowed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ kubectl get secret -n podinfo  --as=system:serviceaccount:flux-system:chart-pipeline-controller app-promotion-credentials\n\nNAME                        TYPE     DATA   AGE\napp-promotion-credentials   Opaque   1      21m\n")),(0,i.kt)("h4",{id:"tokens"},"Tokens"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Create a user account for pull request changes"),": this user context would be used to do any git provider operation,\nand from the security and auditing perspectives, you don't want to impersonate a real user for it.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Expand to see example"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"using bot account",src:n(72816).Z,width:"2074",height:"494"}))),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Do not use long-live tokens"),": set an expiration date and rotate them according to your security policy.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Expand to see example"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"create token with expiration",src:n(10126).Z,width:"1598",height:"926"}))),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Honour the least privilege principle"),": avoid having high privilege tokens. Restrict the token to your just your repo and to just the operations required.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Expand to see example"),(0,i.kt)("p",null,"For example, if the case of GitHub, use ",(0,i.kt)("a",{parentName:"p",href:"https://github.blog/2022-10-18-introducing-fine-grained-personal-access-tokens-for-github/"},"fine-grained tokens")," to only\nallow access to the single repo that your configuration manifests exist."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"create least privileged token",src:n(93949).Z,width:"1596",height:"1380"}))),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Review the tokens on a regular basis following your git provider recommendations"),". Ensure that:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Only the ones that are required are present."),(0,i.kt)("li",{parentName:"ul"},"Tokens close to their expiration date are cycled.")))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Expand to see example"),(0,i.kt)("p",null,"For example, using github and fine-grained tokens you ",(0,i.kt)("a",{parentName:"p",href:"https://github.blog/2022-10-18-introducing-fine-grained-personal-access-tokens-for-github/#approving-and-auditing-personal-access-tokens"},"could do so"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"review tokens",src:n(81483).Z,width:"1750",height:"570"}))),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Review git provider recommendations and examples"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token"},"GitHub")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html"},"GitLab"))),(0,i.kt)("h3",{id:"add-markers-to-app-manifests"},"Add markers to app manifests"),(0,i.kt)("p",null,"The discovery of the version field is done using deterministic markers in a YAML manifest file. An example ",(0,i.kt)("inlineCode",{parentName:"p"},"HelmRelease")," manifest with such a marker looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"{7}","{7}":!0},'---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nspec:\n  chart:\n    spec:\n      version: 0.13.7 # {"$promotion": "pipeline-01:my-app:prod"}\n')),(0,i.kt)("p",null,"The value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"$promotion")," field in the comment is comprised of 3 components separated by colons:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The first field is the Namespace of the pipeline resource that the app is part of. In the example above this is ",(0,i.kt)("inlineCode",{parentName:"li"},"pipeline-01"),"."),(0,i.kt)("li",{parentName:"ol"},"The second field denotes the name of the pipeline resource."),(0,i.kt)("li",{parentName:"ol"},"The third field is the name of the environment that this specific HelmRelease targets. The environment name in the marker needs to match with the ",(0,i.kt)("inlineCode",{parentName:"li"},"name")," field of one of the environments defined in the pipeline's ",(0,i.kt)("inlineCode",{parentName:"li"},".spec.environments")," array.")),(0,i.kt)("p",null,"Weave GitOps Enterprise will look for this marker whenever it receives an event from the respective HelmRelease of one of the leaf clusters and patch the file with the version denoted in the event (see the section above for instructions on setting up notification events from leaf clusters). Finally, it will create a Git provider PR to update the version of the application for the next environment in the pipeline."),(0,i.kt)("h3",{id:"supported-git-providers"},"Supported Git Providers"),(0,i.kt)("p",null,"The following Git providers are currently support by this promotion strategy:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/"},"GitHub")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/"},"GitLab")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.atlassian.com/software/bitbucket/enterprise"},"BitBucket Server / DataCenter"))),(0,i.kt)("p",null,"Select your Git provider via ",(0,i.kt)("inlineCode",{parentName:"p"},".spec.promotion.strategy.pull-request.type"),". For example, for ",(0,i.kt)("inlineCode",{parentName:"p"},"gitlab")," it would look similar to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'promotion:\n  strategy:\n    pull-request:\n      type: gitlab\n      url: "https://gitlab.com/weaveworks/<my-awesome-project.git>"\n      baseBranch: main\n      secretRef:\n        name: gitlab-promotion-credentials\n')),(0,i.kt)("p",null,"More info in the ",(0,i.kt)("a",{parentName:"p",href:"../spec/v1alpha1/pipeline/#pipeline"},"spec"),"."),(0,i.kt)("h3",{id:"credentials-secret"},"Credentials Secret"),(0,i.kt)("p",null,"In the journey of creating a pull request, there are different secrets involved:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Pipeline controller receives events via ",(0,i.kt)("a",{parentName:"li",href:"./#setup-notifications-from-leaf-clusters"},"webhook from leaf clusters"),". An ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/HMAC"},"HMAC")," is used for verification so a shared key should be provided in this case."),(0,i.kt)("li",{parentName:"ol"},"Pipeline controller clones and patches manifests to promote from the pipeline configuration repo. A set of ",(0,i.kt)("a",{parentName:"li",href:"https://fluxcd.io/flux/components/source/gitrepositories/#secret-reference"},"git credentials")," are required."),(0,i.kt)("li",{parentName:"ol"},"Pipeline controller uses git provider api to create the pull request with the promoted manifests. A Personal Access Token (PAT) needs to be created to interact with pipelines git provider API. This PAT is also used to list pull requests from the configured repository.")),(0,i.kt)("p",null,"Create a Kubernetes secret with the previous data."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Expand to see example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'# example to use git over https with basic auth and pat\n$ kubectl create secret generic promotion-credentials \\\n  --namespace=pipeline-01 \\\n  --from-literal="username=<bot account name>" \\\n  --from-literal="password=<token value>" \\\n  --from-literal="token=<token value>" \\\n  --from-literal="hmac-key=<hmac-key value>"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: promotion-credentials\n  namespace: pipeline-01\ndata:\n  username: ZXhhbXBsZQ==\n  password: ZXhhbXBsZS1wYXNzd29yZA==\n  token: Z2hwX01IL3RsTFpXTXZMY0FxVWRYY1ZGL0lGbzh0WDdHNjdsZmRxWQ==\n  hmac-key: OEIzMTNBNjQ0REU0OEVGODgxMTJCQ0VFNTQ3NkE=\ntype: Opaque\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"The Git provider token provided in the ",(0,i.kt)("inlineCode",{parentName:"li"},"token")," field needs to be given permission to create pull requests in the pipeline's repository (defined in ",(0,i.kt)("inlineCode",{parentName:"li"},".spec.promotion.strategy.pull-request.url"),")."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"hmac-key")," field must match the key used for the Provider resource (.spec.secretRef), if specified in the leaf clusters.")))),(0,i.kt)("h3",{id:"define-promotion-in-pipeline-resource"},"Define promotion in pipeline resource"),(0,i.kt)("p",null,"The field ",(0,i.kt)("inlineCode",{parentName:"p"},".spec.promotion.strategy.pull-request")," defines details about the Git repository used for promoting the given app.\nSet the ",(0,i.kt)("inlineCode",{parentName:"p"},"secretRef.name")," field to the name of the Secret created in the previous step and the ",(0,i.kt)("inlineCode",{parentName:"p"},"url")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"branch")," fields to the\nGit repository's HTTPS URL and optionally a specific branch (if the branch is not set, it defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),").\nIf using the ",(0,i.kt)("inlineCode",{parentName:"p"},"generic-hmac")," Provider from leaf clusters, also set the ",(0,i.kt)("inlineCode",{parentName:"p"},".spec.promotion.strategy.secretRef.name")," to the name of the Secret created previously."),(0,i.kt)("p",null,"More info in the ",(0,i.kt)("a",{parentName:"p",href:"../spec/v1alpha1/pipeline/#pipeline"},"spec")),(0,i.kt)("h2",{id:"notification"},"Notification"),(0,i.kt)("p",null,"This section explains how to configure pipelines to work with external CI systems that are responsible for application promotions."),(0,i.kt)("p",null,"This strategy uses the notification controller running on the management cluster, to forward any notifications received by the promotion webhook, from leaf clusters to external CI systems. This requires to ",(0,i.kt)("a",{parentName:"p",href:"https://fluxcd.io/flux/cheatsheets/bootstrap/#enable-notifications-for-third-party-controllers"},"patch")," the Flux manifests of the management cluster, in order to allow objects of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Pipeline")," to be used as event sources. An example of a patch applied to enable this is shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"---\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n- gotk-components.yaml\n- gotk-sync.yaml\npatches:\n- patch: |\n    - op: add\n      path: /spec/versions/0/schema/openAPIV3Schema/properties/spec/properties/eventSources/items/properties/kind/enum/-\n      value: Pipeline\n  target:\n    kind: CustomResourceDefinition\n    name:  alerts.notification.toolkit.fluxcd.io\n")),(0,i.kt)("p",null,"You can now create Provider/Alert resources on the management cluster to forward notifications to external systems. For example, the Provider resource shown below is used to invoke a GitHub Actions workflow on a repository:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Provider\nmetadata:\n  name: promotion-my-app-via-github-actions\nspec:\n  type: githubdispatch\n  address: https://github.com/my-org/my-app-repo\n  secretRef:\n    name: github-credentials\n")),(0,i.kt)("p",null,"To use this Provider, add an Alert that uses the pipeline resource defined on the management cluster as an event source. An example of such an Alert is shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Alert\nmetadata:\n  name: promotion-my-app-via-github-actions\nspec:\n  eventSeverity: info\n  eventSources:\n  - kind: Pipeline\n    name: my-app\n    namespace: my-app-ns\n  providerRef:\n    name: promotion-my-app-via-github-actions\n")),(0,i.kt)("p",null,"The notification controller running on the management cluster is now configured to forward any promotion notifications received from leaf clusters. To actually use this strategy from a pipeline, set the promotion field as shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"{8-9}","{8-9}":!0},"---\napiVersion: pipelines.weave.works/v1alpha1\nkind: Pipeline\nmetadata:\n  name: my-app\n  namespace: my-app-ns\nspec:\n  promotion:\n    notification: {}\n")),(0,i.kt)("p",null,"Promotion notifications from leaf clusters should now be forwarded via the notification controller running on the management cluster and should include information about the version of the application being promoted."),(0,i.kt)("h2",{id:"manual-promotion"},"Manual promotion"),(0,i.kt)("p",null,"The supported strategies mentioned above, do not require any user interaction when handling promotions. However, there is often a need for a human operator to manually approve a promotion to the next environment. To achieve that, set the ",(0,i.kt)("inlineCode",{parentName:"p"},"spec.promotion.manual")," key to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Expand to see example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"{8}","{8}":!0},"apiVersion: pipelines.weave.works/v1alpha1\nkind: Pipeline\nmetadata:\n  name: my-app\n  namespace: my-app-ns\nspec:\n  promotion:\n    manual: true\n    strategy:\n      pull-request:\n        type: github\n        url: https://github.com/my-org/my-app-repo\n        baseBranch: main\n        secretRef:\n          name: promotion-credentials\n"))),(0,i.kt)("p",null,"When this key is set and a promotion is detected, Weave GitOps will prompt the user to manually promote the application to the next environment, via the use of a button shown under the next environment."),(0,i.kt)("figure",null,(0,i.kt)("img",{src:s,style:{width:"70%",height:"70%"}}),(0,i.kt)("figcaption",null,"Manual promotion of an application")),(0,i.kt)("h2",{id:"configuration"},"Configuration"),(0,i.kt)("h3",{id:"retry-logic"},"Retry Logic"),(0,i.kt)("p",null,"By default if a promotion fails, an exponential back-off retry happens and\nreturns with an error only after three retries."),(0,i.kt)("p",null,"Through Helm values, the retry logic is configurable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"# values.yaml\npromotion:\n  retry:\n    # Initial delay between retries.\n    delay: 2\n    # Maximum delay between retries.\n    maxDelay: 20\n    # Number of attempts.\n    threshold: 3\n")),(0,i.kt)("p",null,"The promotion happens through an HTTP endpoint call, that endpoint may has\nconnection timeout limits, that's why the ",(0,i.kt)("inlineCode",{parentName:"p"},"maxDelay")," option is there. If the\ncalculated delay would exceed this value, it will use that as delay. For example\nif the delay values would be ",(0,i.kt)("inlineCode",{parentName:"p"},"[2, 4, 8, 16, 32, 64]"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"maxDelay")," is set to\n15, the list will be ",(0,i.kt)("inlineCode",{parentName:"p"},"[2, 4, 8, 15, 15, 15]"),". With this option, the promotion\nwill be retried on failure, but the sum of delay values will be only 59 seconds\ninstead of 126 seconds."),(0,i.kt)("h3",{id:"rate-limiting"},"Rate Limiting"),(0,i.kt)("p",null,"The promotion endpoint can be exposed to the internet (for example github\nactions), to mitigate DoS attacks, the endpoint has rate limits. By default it's\n20 requests per 30 seconds."),(0,i.kt)("p",null,"Rate limiting can be configured through Helm values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"# values.yaml\npromotion:\n  rateLimit:\n    # Number of requests allowed in set interval.\n    value: 20\n    interval: 30\n")))}h.isMDXComponent=!0},72816:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/bot-account-9b70d2b1f4248abe74dec9fa30327fc5.png"},10126:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/create-token-with-expiration-9958f4ff972dd009c18c4df373771368.png"},93949:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/fine-grained-token-8e56cfc829c5c3a8da466f3a0ef87287.png"},81483:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/manage-fine-grained-f01f8fb2949076750713dd0e6911cb30.png"},63318:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/pipeline-security-violations-57da9a7e41bf736316eca5e2f14fac7a.png"},63360:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/promotion-pr-b8e144adb1ad9f1fba0ebacb0e2abf40.png"}}]);